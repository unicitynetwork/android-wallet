(()=>{"use strict";const t="https://gateway-test.unicity.network";function n(){console.log("Creating client with aggregator URL:",t);const n=new unicity.AggregatorClient(t);return new unicity.StateTransitionClient(n)}window.handleAndroidRequest=async function(t){if(!window.Android)return void console.error("Android bridge not available");let e;try{e=JSON.parse(t)}catch(t){return void console.error("Failed to parse request:",t)}const{id:i,method:r,params:a}=e;try{let t;switch(r){case"mintToken":t=await async function(t,e){try{const i=JSON.parse(t),r=JSON.parse(e),a=n(),o=i.secret.match(/.{2}/g),c=i.nonce.match(/.{2}/g);if(!o||!c)throw new Error("Invalid identity format");const s=new Uint8Array(o.map(t=>parseInt(t,16))),l=new Uint8Array(c.map(t=>parseInt(t,16))),u=await unicity.SigningService.createFromSecret(s,l),w=unicity.TokenId.create(crypto.getRandomValues(new Uint8Array(32))),d=unicity.TokenType.create(crypto.getRandomValues(new Uint8Array(32))),m=await unicity.MaskedPredicate.create(w,d,u,unicity.HashAlgorithm.SHA256,l),y=await unicity.DirectAddress.create(m.reference);let g=null;r.amount&&r.amount>0&&(g=unicity.TokenCoinData.create([[new unicity.CoinId(crypto.getRandomValues(new Uint8Array(32))),BigInt(r.amount)]]));const f=await unicity.MintTransactionData.create(w,d,(new TextEncoder).encode(r.data||""),g,y.toJSON(),crypto.getRandomValues(new Uint8Array(32)),null,null);console.log("Submitting mint transaction...");const S=await a.submitMintTransaction(f);console.log("Mint transaction submitted, waiting for inclusion proof..."),console.log("Using SDK waitInclusionProof utility...");const p=await unicity.waitInclusionProof(a,S);console.log("Inclusion proof received and verified"),console.log("Creating transaction with commitment and inclusion proof...");const k=await a.createTransaction(S,p);console.log("Transaction created successfully:",k);const h=await unicity.TokenState.create(m,null),T=new unicity.Token(h,k,[],[],"2.0");return JSON.stringify({tokenId:w.toJSON(),token:T})}catch(t){throw console.error("Mint token error:",t),new Error(`Failed to mint token: ${t.message}`)}}(a.identityJson,a.tokenDataJson);break;case"prepareTransfer":t=await async function(t,e,i,r=!1){try{const a=JSON.parse(t),o=JSON.parse(i).token,c=a.secret.match(/.{2}/g),s=a.nonce.match(/.{2}/g);if(!c||!s)throw new Error("Invalid sender identity format");const l=new Uint8Array(c.map(t=>parseInt(t,16))),u=new Uint8Array(s.map(t=>parseInt(t,16))),w=await unicity.SigningService.createFromSecret(l,u),d=new unicity.PredicateJsonFactory,m=new unicity.TokenFactory(new unicity.TokenJsonSerializer(d)),y=await m.create(o),g=await unicity.TransactionData.create(y.state,e,crypto.getRandomValues(new Uint8Array(32)),null,(new TextEncoder).encode(""),y.nametagTokens||[]),f=await unicity.Commitment.create(g,w);if(r){const t={commitment:unicity.CommitmentJsonSerializer.serialize(f),token:o};return console.log("Created offline transfer package"),JSON.stringify(t)}{const t=n(),i=await t.submitCommitment(f);if(i.status!==unicity.SubmitCommitmentStatus.SUCCESS)throw new Error(`Failed to submit transfer: ${i.status}`);console.log("Transfer submitted, waiting for inclusion proof...");const r=await unicity.waitInclusionProof(t,f);console.log("Inclusion proof received");const a=await t.createTransaction(f,r),c={transaction:unicity.TransactionJsonSerializer.serialize(a),token:o,recipientAddress:e};return JSON.stringify(c)}}catch(t){throw console.error("Prepare transfer error:",t),new Error(`Failed to prepare transfer: ${t.message}`)}}(a.senderIdentityJson,a.recipientAddress,a.tokenJson,a.isOffline);break;case"finalizeReceivedTransaction":t=await async function(t,e){try{const i=JSON.parse(t),r=JSON.parse(e),a=i.secret.match(/.{2}/g),o=i.nonce.match(/.{2}/g);if(!a||!o)throw new Error("Invalid receiver identity format");const c=new Uint8Array(a.map(t=>parseInt(t,16))),s=new Uint8Array(o.map(t=>parseInt(t,16))),l=await unicity.SigningService.createFromSecret(c,s),u=new unicity.PredicateJsonFactory,w=new unicity.TokenFactory(new unicity.TokenJsonSerializer(u)),d=await w.create(r.token);if(r.commitment){console.log("Processing offline transfer...");const t=new unicity.CommitmentJsonSerializer(u),e=await t.deserialize(d.id,d.type,r.commitment),i=n(),a=await i.submitCommitment(e);if(a.status!==unicity.SubmitCommitmentStatus.SUCCESS)throw new Error(`Failed to submit offline transfer: ${a.status}`);console.log("Offline transfer submitted, waiting for inclusion proof...");const o=await unicity.waitInclusionProof(i,e);console.log("Inclusion proof received");const c=await i.createTransaction(e,o),w=await unicity.MaskedPredicate.create(d.id,d.type,l,unicity.HashAlgorithm.SHA256,s),m=await i.finishTransaction(d,await unicity.TokenState.create(w,null),c);return JSON.stringify({tokenId:m.id.toJSON(),token:m})}if(r.transaction){console.log("Processing online transfer...");const t=new unicity.TransactionJsonSerializer(u),e=await t.deserialize(d.id,d.type,r.transaction),i=await unicity.MaskedPredicate.create(d.id,d.type,l,unicity.HashAlgorithm.SHA256,s),a=n(),o=await a.finishTransaction(d,await unicity.TokenState.create(i,null),e);return JSON.stringify({tokenId:o.id.toJSON(),token:o})}throw new Error("Invalid transfer package: missing commitment or transaction")}catch(t){throw console.error("Finalize received transaction error:",t),new Error(`Failed to finalize received transaction: ${t.message}`)}}(a.receiverIdentityJson,a.transferPackageJson);break;default:throw new Error(`Unknown method: ${r}`)}window.Android.onResult(i,t)}catch(t){console.error(`Error handling ${r}:`,t),window.Android.onError(i,t.message||"Unknown error")}}})();