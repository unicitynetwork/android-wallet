/*! For license information please see unicity-sdk.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.unicity=e():t.unicity=e()}(self,()=>(()=>{"use strict";var t,e,r={d:(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},n={};r.r(n),r.d(n,{AddressScheme:()=>t,AggregatorClient:()=>Rr,Authenticator:()=>ir,BurnPredicate:()=>vr,CoinId:()=>Yr,Commitment:()=>Kr,DataHash:()=>R,DataHasher:()=>vt,DefaultPredicate:()=>xr,DirectAddress:()=>xt,HashAlgorithm:()=>A,HexConverter:()=>b,InclusionProof:()=>gr,InclusionProofVerificationStatus:()=>dr,MINTER_SECRET:()=>$r,MaskedPredicate:()=>Cr,MintTransactionData:()=>Xr,NameTagTokenData:()=>Jr,OfflineCommitment:()=>tn,OfflineStateTransitionClient:()=>nn,OfflineTransaction:()=>yn,PredicateJsonFactory:()=>Ur,PredicateType:()=>Ir,RequestId:()=>_t,Signature:()=>Ct,SigningService:()=>rr,StateTransitionClient:()=>Mr,SubmitCommitmentRequest:()=>yr,SubmitCommitmentResponse:()=>mr,SubmitCommitmentStatus:()=>fr,TOKEN_VERSION:()=>kr,Token:()=>Dr,TokenCoinData:()=>Zr,TokenFactory:()=>jr,TokenId:()=>zr,TokenJsonDeserializer:()=>fn,TokenState:()=>Gr,TokenType:()=>Vr,Transaction:()=>qr,TransactionData:()=>Qr,UnmaskedPredicate:()=>Hr}),function(t){t.DIRECT="DIRECT",t.PROXY="PROXY"}(t||(t={}));class i extends Error{}!function(t){t[t.UNSIGNED_INTEGER=0]="UNSIGNED_INTEGER",t[t.NEGATIVE_INTEGER=32]="NEGATIVE_INTEGER",t[t.BYTE_STRING=64]="BYTE_STRING",t[t.TEXT_STRING=96]="TEXT_STRING",t[t.ARRAY=128]="ARRAY",t[t.MAP=160]="MAP",t[t.TAG=192]="TAG",t[t.FLOAT_SIMPLE_BREAK=224]="FLOAT_SIMPLE_BREAK"}(e||(e={}));const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function s(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function a(t,...e){if(!((r=t)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function c(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function h(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function u(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function l(t,e){return t<<32-e|t>>>e}function d(t,e){return t<<e|t>>>32-e>>>0}const f=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),g=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function y(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function p(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),a(t),t}class m{}function w(t){const e=e=>t().update(p(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function S(t=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(t));if(o&&"function"==typeof o.randomBytes)return Uint8Array.from(o.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}class b{static encode(t){return function(t){if(a(t),f)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=g[t[r]];return e}(t)}static decode(t){return function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(f)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=y(t.charCodeAt(i)),o=y(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}(t)}}class O{static encodeOptional(t,e){return null==t?new Uint8Array([246]):e(t)}static encodeUnsignedInteger(t){if(t<0)throw new i("Only unsigned numbers are allowed.");if(t<24)return new Uint8Array([e.UNSIGNED_INTEGER|Number(t)]);const r=O.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.UNSIGNED_INTEGER|O.getAdditionalInformationBits(r.length),...r])}static encodeByteString(t){if(t.length<24)return new Uint8Array([e.BYTE_STRING|t.length,...t]);const r=O.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.BYTE_STRING|O.getAdditionalInformationBits(r.length),...r,...t])}static encodeTextString(t){const r=(new TextEncoder).encode(t);if(r.length<24)return new Uint8Array([e.TEXT_STRING|r.length,...r]);const n=O.getUnsignedIntegerAsPaddedBytes(r.length);return new Uint8Array([e.TEXT_STRING|O.getAdditionalInformationBits(n.length),...n,...r])}static encodeArray(t){const r=new Uint8Array(t.reduce((t,e)=>t+e.length,0));let n=0;for(const e of t)r.set(e,n),n+=e.length;if(t.length<24)return new Uint8Array([e.ARRAY|t.length,...r]);const i=O.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.ARRAY|O.getAdditionalInformationBits(i.length),...i,...r])}static encodeMap(t){const r=Array.from(t.entries()).map(([t,e])=>[b.decode(t),e]);r.sort(([t],[e])=>{if(t.length!==e.length)return t.length-e.length;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]-e[r];return 0});const n=r.reduce((t,[e,r])=>t+e.length+r.length,0),i=new Uint8Array(n);let o=0;for(const[t,e]of r)i.set(t,o),o+=t.length,i.set(e,o),o+=e.length;if(t.size<24)return new Uint8Array([e.MAP|t.size,...i]);const s=O.getUnsignedIntegerAsPaddedBytes(t.size);return new Uint8Array([e.MAP|O.getAdditionalInformationBits(s.length),...s,...i])}static encodeTag(t,r){if(t<24)return new Uint8Array([e.TAG|Number(t),...r]);const n=O.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.TAG|O.getAdditionalInformationBits(n.length),...n,...r])}static encodeBoolean(t){return t?new Uint8Array([245]):new Uint8Array([244])}static encodeNull(){return new Uint8Array([246])}static getAdditionalInformationBits(t){return 24+Math.ceil(Math.log2(t))}static getUnsignedIntegerAsPaddedBytes(t){if(t<0)throw new i("Only unsigned numbers are allowed.");let e;const r=[];for(e=BigInt(t);e>0;e>>=8n)r.push(Number(255n&e));if(r.length>8)throw new i("Number is not unsigned long.");0===r.length&&r.push(0),r.reverse();const n=new Uint8Array(Math.pow(2,Math.ceil(Math.log2(r.length))));return n.set(r,n.length-r.length),n}}var A,B;!function(t){t[t.SHA256=0]="SHA256",t[t.SHA224=1]="SHA224",t[t.SHA384=2]="SHA384",t[t.SHA512=3]="SHA512",t[t.RIPEMD160=4]="RIPEMD160"}(A||(A={}));class E extends Error{constructor(t){super(t),this.name="HashError"}}!function(t){t[t.MAJOR_TYPE=224]="MAJOR_TYPE",t[t.ADDITIONAL_INFORMATION=31]="ADDITIONAL_INFORMATION"}(B||(B={}));class N{static readOptional(t,e){return 246===N.readByte(t,0)?null:e(t)}static readUnsignedInteger(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.UNSIGNED_INTEGER)throw new i("Major type mismatch, expected unsigned integer.");return N.readLength(r,t,0).length}static readNegativeInteger(){throw new i("Not implemented.")}static readByteString(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.BYTE_STRING)throw new i("Major type mismatch, expected byte string.");const{length:n,position:o}=N.readLength(r,t,0);return N.read(t,o,Number(n))}static readTextString(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.TEXT_STRING)throw new i("Major type mismatch, expected text string.");const{length:n,position:o}=N.readLength(r,t,0);return(new TextDecoder).decode(N.read(t,o,Number(n)))}static readArray(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.ARRAY)throw new i("Major type mismatch, expected array.");const n=N.readLength(r,t,0);let o=n.position;const s=[];for(let e=0;e<n.length;e++){const e=N.readRawCbor(t,o);o=e.position,s.push(e.data)}return s}static readMap(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.MAP)throw new i("Major type mismatch, expected map.");const n=N.readLength(r,t,0);let o=n.position;const s=new Map;for(let e=0;e<n.length;e++){const e=N.readRawCbor(t,o);o=e.position;const r=N.readRawCbor(t,o);o=r.position,s.set(b.encode(e.data),r.data)}return s}static readTag(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.TAG)throw new i("Major type mismatch, expected tag.");const{length:n,position:o}=N.readLength(r,t,0);return{data:N.readRawCbor(t,o).data,tag:n}}static readBoolean(t){const e=N.readByte(t,0);if(245===e)return!0;if(244===e)return!1;throw new i("Type mismatch, expected boolean.")}static readLength(t,r,n){const o=N.readByte(r,n)&B.ADDITIONAL_INFORMATION;if(o<24)return{length:BigInt(o),position:n+1};switch(t){case e.ARRAY:case e.BYTE_STRING:case e.TEXT_STRING:if(31==o)throw new i("Indefinite length array not supported.")}if(o>27)throw new i("Encoded item is not well-formed.");const s=Math.pow(2,o-24);let a=BigInt(0);for(let t=0;t<s;++t)a=a<<8n|BigInt(N.readByte(r,n+1+t));return{length:a,position:n+s+1}}static readRawCbor(t,r){const n=N.readByte(t,r)&B.MAJOR_TYPE,i=N.readLength(n,t,r),o=i.length;let s=i.position;switch(n){case e.BYTE_STRING:case e.TEXT_STRING:s+=Number(o);break;case e.ARRAY:for(let e=0;e<o;e++)s=N.readRawCbor(t,s).position;break;case e.MAP:for(let e=0;e<o;e++)s=N.readRawCbor(t,s).position,s=N.readRawCbor(t,s).position;break;case e.TAG:s=N.readRawCbor(t,s).position}return{data:N.read(t,r,s-r),position:s}}static readByte(t,e){if(t.length<e)throw new i("Premature end of data.");return 255&t[e]}static read(t,e,r){if(t.length<e+r)throw new i("Premature end of data.");return t.subarray(e,e+r)}}class R{algorithm;_data;_imprint;constructor(t,e){this.algorithm=t,this._data=e,this._data=new Uint8Array(e),this._imprint=new Uint8Array(e.length+2),this._imprint.set([(65280&t)>>8,255&t]),this._imprint.set(new Uint8Array(e),2)}get data(){return new Uint8Array(this._data)}get imprint(){return new Uint8Array(this._imprint)}static fromImprint(t){if(t.length<3)throw new E("Imprint must have 2 bytes of algorithm and at least 1 byte of data.");const e=t[0]<<8|t[1];return new R(e,t.subarray(2))}static fromJSON(t){return R.fromImprint(b.decode(t))}static fromCBOR(t){return R.fromImprint(N.readByteString(t))}toJSON(){return b.encode(this._imprint)}toCBOR(){return O.encodeByteString(this._imprint)}equals(t){return b.encode(this._imprint)===b.encode(t._imprint)}toString(){return`[${A[this.algorithm]}]${b.encode(this._data)}`}}function I(t,e,r){return t&e^~t&r}function T(t,e,r){return t&e^t&r^e&r}class v extends m{constructor(t,e,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(t),this.view=u(this.buffer)}update(t){c(this),a(t=p(t));const{view:e,buffer:r,blockLen:n}=this,i=t.length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s===n){const e=u(t);for(;n<=i-o;o+=n)this.process(e,o);continue}r.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){c(this),function(t,e){a(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;e[o++]=128,h(this.buffer.subarray(o)),this.padOffset>n-o&&(this.process(r,0),o=0);for(let t=o;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,h=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+h,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const s=u(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=l/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<d;t++)s.setUint32(4*t,f[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.destroyed=o,t.finished=i,t.length=n,t.pos=s,n%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const x=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),C=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),P=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),H=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),U=(()=>Uint8Array.from(new Array(16).fill(0).map((t,e)=>e)))(),J=(()=>U.map(t=>(9*t+5)%16))(),k=(()=>{const t=[[U],[J]];for(let e=0;e<4;e++)for(let r of t)r.push(r[e].map(t=>H[t]));return t})(),D=(()=>k[0])(),K=(()=>k[1])(),q=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),$=D.map((t,e)=>t.map(t=>q[e][t])),M=K.map((t,e)=>t.map(t=>q[e][t])),L=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),F=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function j(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const z=new Uint32Array(16);class G extends v{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:i}=this;return[t,e,r,n,i]}set(t,e,r,n,i){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(t,e){for(let r=0;r<16;r++,e+=4)z[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,a=s,c=0|this.h3,h=c,u=0|this.h4,l=u;for(let t=0;t<5;t++){const e=4-t,f=L[t],g=F[t],y=D[t],p=K[t],m=$[t],w=M[t];for(let e=0;e<16;e++){const n=d(r+j(t,i,s,c)+z[y[e]]+f,m[e])+u|0;r=u,u=c,c=0|d(s,10),s=i,i=n}for(let t=0;t<16;t++){const r=d(n+j(e,o,a,h)+z[p[t]]+g,w[t])+l|0;n=l,l=h,h=0|d(a,10),a=o,o=r}}this.set(this.h1+s+h|0,this.h2+c+l|0,this.h3+u+n|0,this.h4+r+o|0,this.h0+i+a|0)}roundClean(){h(z)}destroy(){this.destroyed=!0,h(this.buffer),this.set(0,0,0,0,0)}}const V=w(()=>new G),Y=BigInt(2**32-1),Z=BigInt(32);function W(t,e=!1){return e?{h:Number(t&Y),l:Number(t>>Z&Y)}:{h:0|Number(t>>Z&Y),l:0|Number(t&Y)}}const X=(t,e,r)=>t>>>r,Q=(t,e,r)=>t<<32-r|e>>>r,tt=(t,e,r)=>t>>>r|e<<32-r,et=(t,e,r)=>t<<32-r|e>>>r,rt=(t,e,r)=>t<<64-r|e>>>r-32,nt=(t,e,r)=>t>>>r-32|e<<64-r;function it(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}}const ot=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),st=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,at=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),ct=(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,ht=(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),ut=(t,e,r,n,i,o)=>e+r+n+i+o+(t/2**32|0)|0,lt=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),dt=new Uint32Array(64);class ft extends v{constructor(t=32){super(64,t,8,!1),this.A=0|x[0],this.B=0|x[1],this.C=0|x[2],this.D=0|x[3],this.E=0|x[4],this.F=0|x[5],this.G=0|x[6],this.H=0|x[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)dt[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=dt[t-15],r=dt[t-2],n=l(e,7)^l(e,18)^e>>>3,i=l(r,17)^l(r,19)^r>>>10;dt[t]=i+dt[t-7]+n+dt[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:a,G:c,H:h}=this;for(let t=0;t<64;t++){const e=h+(l(s,6)^l(s,11)^l(s,25))+I(s,a,c)+lt[t]+dt[t]|0,u=(l(r,2)^l(r,13)^l(r,22))+T(r,n,i)|0;h=c,c=a,a=s,s=o+e|0,o=i,i=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,h=h+this.H|0,this.set(r,n,i,o,s,a,c,h)}roundClean(){h(dt)}destroy(){this.set(0,0,0,0,0,0,0,0),h(this.buffer)}}class gt extends ft{constructor(){super(28),this.A=0|_[0],this.B=0|_[1],this.C=0|_[2],this.D=0|_[3],this.E=0|_[4],this.F=0|_[5],this.G=0|_[6],this.H=0|_[7]}}const yt=(()=>function(t,e=!1){const r=t.length;let n=new Uint32Array(r),i=new Uint32Array(r);for(let o=0;o<r;o++){const{h:r,l:s}=W(t[o],e);[n[o],i[o]]=[r,s]}return[n,i]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),pt=(()=>yt[0])(),mt=(()=>yt[1])(),wt=new Uint32Array(80),St=new Uint32Array(80);class bt extends v{constructor(t=64){super(128,t,16,!1),this.Ah=0|P[0],this.Al=0|P[1],this.Bh=0|P[2],this.Bl=0|P[3],this.Ch=0|P[4],this.Cl=0|P[5],this.Dh=0|P[6],this.Dl=0|P[7],this.Eh=0|P[8],this.El=0|P[9],this.Fh=0|P[10],this.Fl=0|P[11],this.Gh=0|P[12],this.Gl=0|P[13],this.Hh=0|P[14],this.Hl=0|P[15]}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:h,Fh:u,Fl:l,Gh:d,Gl:f,Hh:g,Hl:y}=this;return[t,e,r,n,i,o,s,a,c,h,u,l,d,f,g,y]}set(t,e,r,n,i,o,s,a,c,h,u,l,d,f,g,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|h,this.Fh=0|u,this.Fl=0|l,this.Gh=0|d,this.Gl=0|f,this.Hh=0|g,this.Hl=0|y}process(t,e){for(let r=0;r<16;r++,e+=4)wt[r]=t.getUint32(e),St[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|wt[t-15],r=0|St[t-15],n=tt(e,r,1)^tt(e,r,8)^X(e,0,7),i=et(e,r,1)^et(e,r,8)^Q(e,r,7),o=0|wt[t-2],s=0|St[t-2],a=tt(o,s,19)^rt(o,s,61)^X(o,0,6),c=et(o,s,19)^nt(o,s,61)^Q(o,s,6),h=at(i,c,St[t-7],St[t-16]),u=ct(h,n,a,wt[t-7],wt[t-16]);wt[t]=0|u,St[t]=0|h}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:c,Dl:h,Eh:u,El:l,Fh:d,Fl:f,Gh:g,Gl:y,Hh:p,Hl:m}=this;for(let t=0;t<80;t++){const e=tt(u,l,14)^tt(u,l,18)^rt(u,l,41),w=et(u,l,14)^et(u,l,18)^nt(u,l,41),S=u&d^~u&g,b=ht(m,w,l&f^~l&y,mt[t],St[t]),O=ut(b,p,e,S,pt[t],wt[t]),A=0|b,B=tt(r,n,28)^rt(r,n,34)^rt(r,n,39),E=et(r,n,28)^nt(r,n,34)^nt(r,n,39),N=r&i^r&s^i&s,R=n&o^n&a^o&a;p=0|g,m=0|y,g=0|d,y=0|f,d=0|u,f=0|l,({h:u,l}=it(0|c,0|h,0|O,0|A)),c=0|s,h=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const I=ot(A,E,R);r=st(I,O,B,N),n=0|I}({h:r,l:n}=it(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=it(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=it(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:h}=it(0|this.Dh,0|this.Dl,0|c,0|h)),({h:u,l}=it(0|this.Eh,0|this.El,0|u,0|l)),({h:d,l:f}=it(0|this.Fh,0|this.Fl,0|d,0|f)),({h:g,l:y}=it(0|this.Gh,0|this.Gl,0|g,0|y)),({h:p,l:m}=it(0|this.Hh,0|this.Hl,0|p,0|m)),this.set(r,n,i,o,s,a,c,h,u,l,d,f,g,y,p,m)}roundClean(){h(wt,St)}destroy(){h(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ot extends bt{constructor(){super(48),this.Ah=0|C[0],this.Al=0|C[1],this.Bh=0|C[2],this.Bl=0|C[3],this.Ch=0|C[4],this.Cl=0|C[5],this.Dh=0|C[6],this.Dl=0|C[7],this.Eh=0|C[8],this.El=0|C[9],this.Fh=0|C[10],this.Fl=0|C[11],this.Gh=0|C[12],this.Gl=0|C[13],this.Hh=0|C[14],this.Hl=0|C[15]}}const At=w(()=>new ft),Bt=At,Et=w(()=>new gt),Nt=w(()=>new bt),Rt=w(()=>new Ot);class It extends Error{constructor(t){super(`Unsupported hash algorithm: ${t}`),this.name="UnsupportedHashAlgorithm"}}const Tt={[A.RIPEMD160]:V,[A.SHA224]:Et,[A.SHA256]:Bt,[A.SHA384]:Rt,[A.SHA512]:Nt};class vt{algorithm;_messageDigest;constructor(t){if(this.algorithm=t,!Tt[t])throw new It(t);this._messageDigest=Tt[t].create()}update(t){return this._messageDigest.update(t),this}digest(){return Promise.resolve(new R(this.algorithm,this._messageDigest.digest()))}}class xt{data;checksum;constructor(t,e){this.data=t,this.checksum=e,this.checksum=new Uint8Array(e.slice(0,4))}get scheme(){return t.DIRECT}static async create(t){const e=await new vt(A.SHA256).update(t.toCBOR()).digest();return new xt(t,e.data.slice(0,4))}static async fromJSON(e){const[r,n]=e.split("://");if(r!==t.DIRECT)throw new Error(`Invalid address scheme: expected ${t.DIRECT}, got ${r}`);const i=n.slice(-8),o=await xt.create(R.fromCBOR(b.decode(n.slice(0,-8))));if(b.encode(o.checksum)!==i)throw new Error(`Invalid checksum for DirectAddress: expected ${i}, got ${b.encode(o.checksum)}`);return o}toJSON(){return this.toString()}toCBOR(){return O.encodeTextString(this.toString())}toString(){return`${this.scheme}://${b.encode(this.data.toCBOR())}${b.encode(this.checksum)}`}}class _t{hash;constructor(t){this.hash=t}static create(t,e){return _t.createFromImprint(t,e.imprint)}static async createFromImprint(t,e){const r=await new vt(A.SHA256).update(t).update(e).digest();return new _t(r)}static fromCBOR(t){return new _t(R.fromCBOR(t))}static fromJSON(t){return new _t(R.fromJSON(t))}toBigInt(){return BigInt(`0x01${b.encode(this.hash.imprint)}`)}toJSON(){return this.hash.toJSON()}toCBOR(){return this.hash.toCBOR()}equals(t){return this.hash.equals(t.hash)}toString(){return`RequestId[${this.hash.toString()}]`}}class Ct{_bytes;recovery;algorithm="secp256k1";constructor(t,e){this._bytes=t,this.recovery=e,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static fromCBOR(t){return Ct.decode(N.readByteString(t))}static decode(t){if(65!==t.length)throw new Error("Signature must contain signature and recovery byte.");return new Ct(t.slice(0,-1),t[t.length-1])}static fromJSON(t){return Ct.decode(b.decode(t))}toJSON(){return b.encode(this.encode())}toCBOR(){return O.encodeByteString(this.encode())}encode(){return new Uint8Array([...this._bytes,this.recovery])}toString(){return`${b.encode(this.encode())}`}}class Pt extends m{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");s(t.outputLen),s(t.blockLen)}(t);const r=p(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),h(i)}update(t){return c(this),this.iHash.update(t),this}digestInto(t){c(this),a(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ht=(t,e,r)=>new Pt(t,e).update(r).digest();Ht.create=(t,e)=>new Pt(t,e);const Ut=BigInt(0),Jt=BigInt(1);function kt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function Dt(t){if(!kt(t))throw new Error("Uint8Array expected")}function Kt(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function qt(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function $t(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Ut:BigInt("0x"+t)}const Mt="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,Lt=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Ft(t){if(Dt(t),Mt)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=Lt[t[r]];return e}function jt(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function zt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(Mt)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=jt(t.charCodeAt(i)),o=jt(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}function Gt(t){return $t(Ft(t))}function Vt(t){return Dt(t),$t(Ft(Uint8Array.from(t).reverse()))}function Yt(t,e){return zt(t.toString(16).padStart(2*e,"0"))}function Zt(t,e){return Yt(t,e).reverse()}function Wt(t,e,r){let n;if("string"==typeof e)try{n=zt(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!kt(e))throw new Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(t+" of length "+r+" expected, got "+i);return n}function Xt(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];Dt(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const Qt=t=>"bigint"==typeof t&&Ut<=t;function te(t,e,r){return Qt(t)&&Qt(e)&&Qt(r)&&e<=t&&t<r}function ee(t,e,r,n){if(!te(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}const re=t=>(Jt<<BigInt(t))-Jt,ne=t=>new Uint8Array(t),ie=t=>Uint8Array.from(t),oe={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||kt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function se(t,e,r={}){const n=(e,r,n)=>{const i=oe[r];if("function"!=typeof i)throw new Error("invalid validator function");const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error("param "+String(e)+" is invalid. Expected "+r+", got "+o)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}function ae(t){const e=new WeakMap;return(r,...n)=>{const i=e.get(r);if(void 0!==i)return i;const o=t(r,...n);return e.set(r,o),o}}const ce=BigInt(0),he=BigInt(1),ue=BigInt(2),le=BigInt(3),de=BigInt(4),fe=BigInt(5),ge=BigInt(8);function ye(t,e){const r=t%e;return r>=ce?r:e+r}function pe(t,e,r){let n=t;for(;e-- >ce;)n*=n,n%=r;return n}function me(t,e){if(t===ce)throw new Error("invert: expected non-zero number");if(e<=ce)throw new Error("invert: expected positive modulus, got "+e);let r=ye(t,e),n=e,i=ce,o=he,s=he,a=ce;for(;r!==ce;){const t=n/r,e=n%r,c=i-s*t,h=o-a*t;n=r,r=e,i=s,o=a,s=c,a=h}if(n!==he)throw new Error("invert: does not exist");return ye(i,e)}function we(t,e){const r=(t.ORDER+he)/de,n=t.pow(e,r);if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root");return n}function Se(t,e){const r=(t.ORDER-fe)/ge,n=t.mul(e,ue),i=t.pow(n,r),o=t.mul(e,i),s=t.mul(t.mul(o,ue),i),a=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),e))throw new Error("Cannot find square root");return a}const be=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Oe(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),i=e.reduce((e,r,i)=>t.is0(r)?e:(n[i]=e,t.mul(e,r)),t.ONE),o=t.inv(i);return e.reduceRight((e,r,i)=>t.is0(r)?e:(n[i]=t.mul(e,n[i]),t.mul(e,r)),o),n}function Ae(t,e){const r=(t.ORDER-he)/ue,n=t.pow(e,r),i=t.eql(n,t.ONE),o=t.eql(n,t.ZERO),s=t.eql(n,t.neg(t.ONE));if(!i&&!o&&!s)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Be(t,e){void 0!==e&&s(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Ee(t,e,r=!1,n={}){if(t<=ce)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:o}=Be(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const a=Object.freeze({ORDER:t,isLE:r,BITS:i,BYTES:o,MASK:re(i),ZERO:ce,ONE:he,create:e=>ye(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return ce<=e&&e<t},is0:t=>t===ce,isOdd:t=>(t&he)===he,neg:e=>ye(-e,t),eql:(t,e)=>t===e,sqr:e=>ye(e*e,t),add:(e,r)=>ye(e+r,t),sub:(e,r)=>ye(e-r,t),mul:(e,r)=>ye(e*r,t),pow:(t,e)=>function(t,e,r){if(r<ce)throw new Error("invalid exponent, negatives unsupported");if(r===ce)return t.ONE;if(r===he)return e;let n=t.ONE,i=e;for(;r>ce;)r&he&&(n=t.mul(n,i)),i=t.sqr(i),r>>=he;return n}(a,t,e),div:(e,r)=>ye(e*me(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>me(e,t),sqrt:n.sqrt||(e=>{return s||(s=(r=t)%de===le?we:r%ge===fe?Se:function(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-he,r=0;for(;e%ue===ce;)e/=ue,r++;let n=ue;const i=Ee(t);for(;1===Ae(i,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return we;let o=i.pow(n,e);const s=(e+he)/ue;return function(t,n){if(t.is0(n))return n;if(1!==Ae(t,n))throw new Error("Cannot find square root");let i=r,a=t.mul(t.ONE,o),c=t.pow(n,e),h=t.pow(n,s);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,r=t.sqr(c);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===i)throw new Error("Cannot find square root");const n=he<<BigInt(i-e-1),o=t.pow(a,n);i=e,a=t.sqr(o),c=t.mul(c,a),h=t.mul(h,o)}return h}}(r)),s(a,e);var r}),toBytes:t=>r?Zt(t,o):Yt(t,o),fromBytes:t=>{if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);return r?Vt(t):Gt(t)},invertBatch:t=>Oe(a,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(a)}function Ne(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Re(t){const e=Ne(t);return e+Math.ceil(e/2)}const Ie=BigInt(0),Te=BigInt(1);function ve(t,e){const r=e.negate();return t?r:e}function xe(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function _e(t,e){xe(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:re(t),maxNumber:r,shiftBy:BigInt(t)}}function Ce(t,e,r){const{windowSize:n,mask:i,maxNumber:o,shiftBy:s}=r;let a=Number(t&i),c=t>>s;a>n&&(a-=o,c+=Te);const h=e*n;return{nextN:c,offset:h+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:h}}const Pe=new WeakMap,He=new WeakMap;function Ue(t){return He.get(t)||1}function Je(t,e,r,n){(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})})(r,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}(n,e);const i=r.length,o=n.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,a=function(t){let e;for(e=0;t>Ut;t>>=Jt,e+=1);return e}(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const h=re(c),u=new Array(Number(h)+1).fill(s);let l=s;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){u.fill(s);for(let e=0;e<o;e++){const i=n[e],o=Number(i>>BigInt(t)&h);u[o]=u[o].add(r[e])}let e=s;for(let t=u.length-1,r=s;t>0;t--)r=r.add(u[t]),e=e.add(r);if(l=l.add(e),0!==t)for(let t=0;t<c;t++)l=l.double()}return l}function ke(t){return se(t.Fp,be.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),se(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Be(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function De(t){void 0!==t.lowS&&Kt("lowS",t.lowS),void 0!==t.prehash&&Kt("prehash",t.prehash)}class Ke extends Error{constructor(t=""){super(t)}}const qe={Err:Ke,_tlv:{encode:(t,e)=>{const{Err:r}=qe;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,i=qt(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?qt(i.length/2|128):"";return qt(t)+o+i+e},decode(t,e){const{Err:r}=qe;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const i=e[n++];let o=0;if(128&i){const t=127&i;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const s=e.subarray(n,n+t);if(s.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===s[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of s)o=o<<8|t;if(n+=t,o<128)throw new r("tlv.decode(long): not minimal encoding")}else o=i;const s=e.subarray(n,n+o);if(s.length!==o)throw new r("tlv.decode: wrong value length");return{v:s,l:e.subarray(n+o)}}},_int:{encode(t){const{Err:e}=qe;if(t<Me)throw new e("integer: negative integers are not allowed");let r=qt(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=qe;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Gt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=qe,i=Wt("signature",t),{v:o,l:s}=n.decode(48,i);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:h,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(h)}},hexFromSig(t){const{_tlv:e,_int:r}=qe,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}};function $e(t,e){return Ft(Yt(t,e))}const Me=BigInt(0),Le=BigInt(1),Fe=(BigInt(2),BigInt(3)),je=BigInt(4);function ze(t){const e=function(t){const e=ke(t);return se(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n,nByteLength:i,nBitLength:o}=e,s=r.BYTES+1,a=2*r.BYTES+1;function c(t){return ye(t,n)}function h(t){return me(t,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=function(t){const e=function(t){const e=ke(t);se(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}(t),{Fp:r}=e,n=Ee(e.n,e.nBitLength),i=e.toBytes||((t,e,n)=>{const i=e.toAffine();return Xt(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function s(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}function a(t,e){const n=r.sqr(e),i=s(t);return r.eql(n,i)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=r.mul(r.pow(e.a,Fe),je),h=r.mul(r.sqr(e.b),BigInt(27));if(r.is0(r.add(c,h)))throw new Error("bad curve params: a or b");function u(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(kt(t)&&(t=Ft(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:Gt(Wt("private key",t,n))}catch(e){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return i&&(s=ye(s,o)),ee("private key",s,Le,o),s}function l(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const d=ae((t,e)=>{const{px:n,py:i,pz:o}=t;if(r.eql(o,r.ONE))return{x:n,y:i};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(o));const a=r.mul(n,e),c=r.mul(i,e),h=r.mul(o,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(h,r.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),f=ae(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:n,y:i}=t.toAffine();if(!r.isValid(n)||!r.isValid(i))throw new Error("bad point: x or y not FE");if(!a(n,i))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(t,e,n){if(null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e)||r.is0(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");this.px=t,this.py=e,this.pz=n,Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?g.ZERO:new g(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=Oe(r,t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(o(Wt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(u(t))}static msm(t,e){return Je(g,n,t,e)}_setWindowSize(t){m.setWindowSize(this,t)}assertValidity(){f(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){l(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:a}=t,c=r.eql(r.mul(e,a),r.mul(o,i)),h=r.eql(r.mul(n,a),r.mul(s,i));return c&&h}negate(){return new g(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,Fe),{px:o,py:s,pz:a}=this;let c=r.ZERO,h=r.ZERO,u=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),f=r.mul(a,a),y=r.mul(o,s);return y=r.add(y,y),u=r.mul(o,a),u=r.add(u,u),c=r.mul(t,u),h=r.mul(i,f),h=r.add(c,h),c=r.sub(d,h),h=r.add(d,h),h=r.mul(c,h),c=r.mul(y,c),u=r.mul(i,u),f=r.mul(t,f),y=r.sub(l,f),y=r.mul(t,y),y=r.add(y,u),u=r.add(l,l),l=r.add(u,l),l=r.add(l,f),l=r.mul(l,y),h=r.add(h,l),f=r.mul(s,a),f=r.add(f,f),l=r.mul(f,y),c=r.sub(c,l),u=r.mul(f,d),u=r.add(u,u),u=r.add(u,u),new g(c,h,u)}add(t){l(t);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=t;let h=r.ZERO,u=r.ZERO,d=r.ZERO;const f=e.a,y=r.mul(e.b,Fe);let p=r.mul(n,s),m=r.mul(i,a),w=r.mul(o,c),S=r.add(n,i),b=r.add(s,a);S=r.mul(S,b),b=r.add(p,m),S=r.sub(S,b),b=r.add(n,o);let O=r.add(s,c);return b=r.mul(b,O),O=r.add(p,w),b=r.sub(b,O),O=r.add(i,o),h=r.add(a,c),O=r.mul(O,h),h=r.add(m,w),O=r.sub(O,h),d=r.mul(f,b),h=r.mul(y,w),d=r.add(h,d),h=r.sub(m,d),d=r.add(m,d),u=r.mul(h,d),m=r.add(p,p),m=r.add(m,p),w=r.mul(f,w),b=r.mul(y,b),m=r.add(m,w),w=r.sub(p,w),w=r.mul(f,w),b=r.add(b,w),p=r.mul(m,b),u=r.add(u,p),p=r.mul(O,b),h=r.mul(S,h),h=r.sub(h,p),p=r.mul(S,m),d=r.mul(O,d),d=r.add(d,p),new g(h,u,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return m.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:i}=e;ee("scalar",t,Me,i);const o=g.ZERO;if(t===Me)return o;if(this.is0()||t===Le)return this;if(!n||m.hasPrecomputes(this))return m.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:s,k1:a,k2neg:c,k2:h}=n.splitScalar(t),u=o,l=o,d=this;for(;a>Me||h>Me;)a&Le&&(u=u.add(d)),h&Le&&(l=l.add(d)),d=d.double(),a>>=Le,h>>=Le;return s&&(u=u.negate()),c&&(l=l.negate()),l=new g(r.mul(l.px,n.beta),l.py,l.pz),u.add(l)}multiply(t){const{endo:n,n:i}=e;let o,s;if(ee("scalar",t,Le,i),n){const{k1neg:e,k1:i,k2neg:a,k2:c}=n.splitScalar(t);let{p:h,f:u}=this.wNAF(i),{p:l,f:d}=this.wNAF(c);h=m.constTimeNegate(e,h),l=m.constTimeNegate(a,l),l=new g(r.mul(l.px,n.beta),l.py,l.pz),o=h.add(l),s=u.add(d)}else{const{p:e,f:r}=this.wNAF(t);o=e,s=r}return g.normalizeZ([o,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=g.BASE,i=(t,e)=>e!==Me&&e!==Le&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,r));return o.is0()?void 0:o}toAffine(t){return d(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Le)return!0;if(r)return r(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Le?this:r?r(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return Kt("isCompressed",t),this.assertValidity(),i(g,this,t)}toHex(t=!0){return Kt("isCompressed",t),Ft(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,r.ONE),g.ZERO=new g(r.ZERO,r.ONE,r.ZERO);const{endo:y,nBitLength:p}=e,m=(w=g,S=y?Math.ceil(p/2):p,{constTimeNegate:ve,hasPrecomputes:t=>1!==Ue(t),unsafeLadder(t,e,r=w.ZERO){let n=t;for(;e>Ie;)e&Te&&(r=r.add(n)),n=n.double(),e>>=Te;return r},precomputeWindow(t,e){const{windows:r,windowSize:n}=_e(e,S),i=[];let o=t,s=o;for(let t=0;t<r;t++){s=o,i.push(s);for(let t=1;t<n;t++)s=s.add(o),i.push(s);o=s.double()}return i},wNAF(t,e,r){let n=w.ZERO,i=w.BASE;const o=_e(t,S);for(let t=0;t<o.windows;t++){const{nextN:s,offset:a,isZero:c,isNeg:h,isNegF:u,offsetF:l}=Ce(r,t,o);r=s,c?i=i.add(ve(u,e[l])):n=n.add(ve(h,e[a]))}return{p:n,f:i}},wNAFUnsafe(t,e,r,n=w.ZERO){const i=_e(t,S);for(let t=0;t<i.windows&&r!==Ie;t++){const{nextN:o,offset:s,isZero:a,isNeg:c}=Ce(r,t,i);if(r=o,!a){const t=e[s];n=n.add(c?t.negate():t)}}return n},getPrecomputes(t,e,r){let n=Pe.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&Pe.set(e,r(n))),n},wNAFCached(t,e,r){const n=Ue(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)},wNAFCachedUnsafe(t,e,r,n){const i=Ue(t);return 1===i?this.unsafeLadder(t,e,n):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),e,n)},setWindowSize(t,e){xe(e,S),He.set(t,e),Pe.delete(t)}});var w,S;return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:u,weierstrassEquation:s,isWithinCurveOrder:function(t){return te(t,Le,e.n)}}}({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=Xt;return Kt("isCompressed",n),n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],i=t.subarray(1);if(e!==s||2!==n&&3!==n){if(e===a&&4===n)return{x:r.fromBytes(i.subarray(0,r.BYTES)),y:r.fromBytes(i.subarray(r.BYTES,2*r.BYTES))};throw new Error("invalid Point, expected length of "+s+", or uncompressed "+a+", got "+e)}{const t=Gt(i);if(!te(t,Le,r.ORDER))throw new Error("Point is not on curve");const e=d(t);let o;try{o=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~n)!=((o&Le)===Le)&&(o=r.neg(o)),{x:t,y:o}}}});function g(t){return t>n>>Le}const y=(t,e,r)=>Gt(t.slice(e,r));class p{constructor(t,e,r){ee("r",t,Le,n),ee("s",e,Le,n),this.r=t,this.s=e,null!=r&&(this.recovery=r),Object.freeze(this)}static fromCompact(t){const e=i;return t=Wt("compactSignature",t,2*e),new p(y(t,0,e),y(t,e,2*e))}static fromDER(t){const{r:e,s:r}=qe.toSig(Wt("DER",t));return new p(e,r)}assertValidity(){}addRecoveryBit(t){return new p(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,s=b(Wt("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?n+e.n:n;if(a>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=1&o?"03":"02",d=u.fromHex(l+$e(a,r.BYTES)),f=h(a),g=c(-s*f),y=c(i*f),p=u.BASE.multiplyAndAddUnsafe(d,g,y);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return zt(this.toDERHex())}toDERHex(){return qe.hexFromSig(this)}toCompactRawBytes(){return zt(this.toCompactHex())}toCompactHex(){const t=i;return $e(this.r,t)+$e(this.s,t)}}const m={isValidPrivateKey(t){try{return l(t),!0}catch(t){return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const t=Re(e.n);return function(t,e,r=!1){const n=t.length,i=Ne(e),o=Re(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const s=ye(r?Vt(t):Gt(t),e-he)+he;return r?Zt(s,i):Yt(s,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=u.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function w(t){if("bigint"==typeof t)return!1;if(t instanceof u)return!0;const n=Wt("key",t).length,o=r.BYTES,s=o+1,a=2*o+1;return e.allowedPrivateKeyLengths||i===s?void 0:n===s||n===a}const S=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=Gt(t),r=8*t.length-o;return r>0?e>>BigInt(r):e},b=e.bits2int_modN||function(t){return c(S(t))},O=re(o);function A(t){return ee("num < 2^"+o,t,Me,O),Yt(t,i)}const B={lowS:e.lowS,prehash:!1},E={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return u.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(!0===w(t))throw new Error("first arg must be private key");if(!1===w(e))throw new Error("second arg must be public key");return u.fromHex(e).multiply(l(t)).toRawBytes(r)},sign:function(t,n,i=B){const{seed:o,k2sig:s}=function(t,n,i=B){if(["recovered","canonical"].some(t=>t in i))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:s}=e;let{lowS:a,prehash:d,extraEntropy:y}=i;null==a&&(a=!0),t=Wt("msgHash",t),De(i),d&&(t=Wt("prehashed msgHash",o(t)));const m=b(t),w=l(n),O=[A(w),A(m)];if(null!=y&&!1!==y){const t=!0===y?s(r.BYTES):y;O.push(Wt("extraEntropy",t))}const E=Xt(...O),N=m;return{seed:E,k2sig:function(t){const e=S(t);if(!f(e))return;const r=h(e),n=u.BASE.multiply(e).toAffine(),i=c(n.x);if(i===Me)return;const o=c(r*c(N+i*w));if(o===Me)return;let s=(n.x===i?0:2)|Number(n.y&Le),l=o;return a&&g(o)&&(l=function(t){return g(t)?c(-t):t}(o),s^=1),new p(i,l,s)}}}(t,n,i),a=e;return function(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=ne(t),i=ne(t),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...t)=>r(i,n,...t),c=(t=ne(0))=>{i=a(ie([0]),t),n=a(),0!==t.length&&(i=a(ie([1]),t),n=a())},h=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return Xt(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(h()));)c();return s(),r}}(a.hash.outputLen,a.nByteLength,a.hmac)(o,s)},verify:function(t,r,n,i=E){const o=t;r=Wt("msgHash",r),n=Wt("publicKey",n);const{lowS:s,prehash:a,format:l}=i;if(De(i),"strict"in i)throw new Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw new Error("format must be compact or der");const d="string"==typeof o||kt(o),f=!d&&!l&&"object"==typeof o&&null!==o&&"bigint"==typeof o.r&&"bigint"==typeof o.s;if(!d&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,y;try{if(f&&(g=new p(o.r,o.s)),d){try{"compact"!==l&&(g=p.fromDER(o))}catch(t){if(!(t instanceof qe.Err))throw t}g||"der"===l||(g=p.fromCompact(o))}y=u.fromHex(n)}catch(t){return!1}if(!g)return!1;if(s&&g.hasHighS())return!1;a&&(r=e.hash(r));const{r:m,s:w}=g,S=b(r),O=h(w),A=c(S*O),B=c(m*O),N=u.BASE.multiplyAndAddUnsafe(y,A,B)?.toAffine();return!!N&&c(N.x)===m},ProjectivePoint:u,Signature:p,utils:m}}function Ge(t){return{hash:t,hmac:(e,...r)=>Ht(t,e,function(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];a(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}(...r)),randomBytes:S}}const Ve=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ye=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ze=BigInt(0),We=BigInt(1),Xe=BigInt(2),Qe=(t,e)=>(t+e/Xe)/e;const tr=Ee(Ve,void 0,void 0,{sqrt:function(t){const e=Ve,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),h=t*t*t%e,u=h*h*t%e,l=pe(u,r,e)*u%e,d=pe(l,r,e)*u%e,f=pe(d,Xe,e)*h%e,g=pe(f,i,e)*f%e,y=pe(g,o,e)*g%e,p=pe(y,a,e)*y%e,m=pe(p,c,e)*p%e,w=pe(m,a,e)*y%e,S=pe(w,r,e)*u%e,b=pe(S,s,e)*g%e,O=pe(b,n,e)*h%e,A=pe(O,Xe,e);if(!tr.eql(tr.sqr(A),t))throw new Error("Cannot find square root");return A}}),er=function(t,e){const r=e=>ze({...t,...Ge(e)});return{...r(e),create:r}}({a:Ze,b:BigInt(7),Fp:tr,n:Ye,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ye,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-We*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=Qe(o*t,e),c=Qe(-n*t,e);let h=ye(t-a*r-c*i,e),u=ye(-a*n-c*o,e);const l=h>s,d=u>s;if(l&&(h=e-h),d&&(u=e-u),h>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:h,k2neg:d,k2:u}}}},At);class rr{privateKey;_publicKey;constructor(t){this.privateKey=t,this.privateKey=new Uint8Array(t),this._publicKey=er.getPublicKey(this.privateKey,!0)}get publicKey(){return new Uint8Array(this._publicKey)}get algorithm(){return"secp256k1"}static generatePrivateKey(){return er.utils.randomPrivateKey()}static async createFromSecret(t,e){const r=new vt(A.SHA256);r.update(t),e&&r.update(e);const n=await r.digest();return new rr(n.data)}static verifySignatureWithRecoveredPublicKey(t,e){const r=er.Signature.fromCompact(e.bytes).addRecoveryBit(e.recovery).recoverPublicKey(t.data).toRawBytes();return rr.verifyWithPublicKey(t,e.bytes,r)}static verifyWithPublicKey(t,e,r){return Promise.resolve(er.verify(e,t.data,r,{format:"compact"}))}verify(t,e){return rr.verifyWithPublicKey(t,e.bytes,this._publicKey)}sign(t){const e=er.sign(t.data,this.privateKey);return Promise.resolve(new Ct(e.toCompactRawBytes(),e.recovery))}}function nr(t,...e){if(0===t.length)return"";let r=t[0].split("\n");if(0!==r.shift()?.length)throw new Error("First line must be empty");const n=r[0].length-r[0].trimStart().length,i=[];for(let o=0;o<t.length;o++){i.push(`${i.pop()||""}${r[0].slice(Math.min(r[0].length-r[0].trim().length,n))}`);for(let t=1;t<r.length;t++)i.push(r[t].slice(n));const s=i.pop(),a=s.length-s.trimStart().length,c=o<e.length?String(e[o]).split("\n"):[""];i.push(`${s}${c[0]}`);for(let t=1;t<c.length;t++)i.push(`${" ".repeat(a)}${c[t]}`);r=o+1<t.length?t[o+1].split("\n"):[]}return i.join("\n")}class ir{algorithm;_publicKey;signature;stateHash;constructor(t,e,r,n){this.algorithm=t,this._publicKey=e,this.signature=r,this.stateHash=n,this._publicKey=new Uint8Array(e)}get publicKey(){return new Uint8Array(this._publicKey)}static async create(t,e,r){return new ir(t.algorithm,t.publicKey,await t.sign(e),r)}static fromJSON(t){if(!ir.isJSON(t))throw new Error("Parsing authenticator dto failed.");return new ir(t.algorithm,b.decode(t.publicKey),Ct.fromJSON(t.signature),R.fromJSON(t.stateHash))}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"signature"in t&&"string"==typeof t.signature&&"stateHash"in t&&"string"==typeof t.stateHash}static fromCBOR(t){const e=N.readArray(t);return new ir(N.readTextString(e[0]),N.readByteString(e[1]),Ct.decode(N.readByteString(e[2])),R.fromImprint(N.readByteString(e[3])))}toCBOR(){return O.encodeArray([O.encodeTextString(this.algorithm),O.encodeByteString(this.publicKey),O.encodeByteString(this.signature.encode()),O.encodeByteString(this.stateHash.imprint)])}toJSON(){return{algorithm:this.algorithm,publicKey:b.encode(this.publicKey),signature:this.signature.toJSON(),stateHash:this.stateHash.toJSON()}}verify(t){return rr.verifyWithPublicKey(t,this.signature.bytes,this.publicKey)}calculateRequestId(){return _t.create(this._publicKey,this.stateHash)}toString(){return nr`
      Authenticator
        Public Key: ${b.encode(this._publicKey)}
        Signature Algorithm: ${this.algorithm}
        Signature: ${this.signature.toString()}
        State Hash: ${this.stateHash.toString()}`}}class or{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static async create(t,e){const r=await new vt(A.SHA256).update(t.toCBOR()).update(e.imprint).digest();return new or(r.imprint)}equals(t){return!!ArrayBuffer.isView(t)&&b.encode(this.bytes)===b.encode(new Uint8Array(t.buffer,t.byteOffset,t.byteLength))}toString(){return`LeafValue[${b.encode(this.bytes)}]`}}class sr{path;_value;hash;constructor(t,e,r){this.path=t,this._value=e,this.hash=r}get value(){return new Uint8Array(this._value)}finalize(){return Promise.resolve(this)}toString(){return`\n      Leaf[${this.path}]\n        Value: ${b.encode(this._value)}\n    `}}class ar{static decode(t,e,r){if(e=e??0,r=r??t.length,e<0||r<0||e+r>t.length)throw new Error("Index out of bounds");let n=0n;for(let i=0;i<r;++i)n=n<<8n|BigInt(255&t[e+i]);return n}static encode(t){const e=[];for(let r=t;r>0n;r>>=8n)e.unshift(Number(0xffn&r));return new Uint8Array(e)}}class cr{_value;constructor(t){this._value=t,this._value=t?new Uint8Array(t):null}get value(){return this._value?new Uint8Array(this._value):null}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Parsing merkle tree path step branch failed.");const e=t.at(0);return new cr(e?b.decode(e):null)}static fromCBOR(t){const e=N.readArray(t);return new cr(N.readOptional(e[0],N.readByteString))}toCBOR(){return O.encodeArray([O.encodeOptional(this._value,O.encodeByteString)])}toJSON(){return this._value?[b.encode(this._value)]:[]}toString(){return`MerkleTreePathStepBranch[${this._value?b.encode(this._value):"null"}]`}}class hr{path;sibling;branch;constructor(t,e,r){this.path=t,this.sibling=e,this.branch=r}static createWithoutBranch(t,e){return new hr(t,e?.hash??null,null)}static create(t,e,r){return new hr(t,r?.hash??null,new cr(null==e?null:e instanceof sr?e.value:e.childrenHash.data))}static isJSON(t){return"object"==typeof t&&null!==t&&"path"in t&&"string"==typeof t.path&&"sibling"in t&&"branch"in t}static fromJSON(t){if(!hr.isJSON(t))throw new Error("Parsing merkle tree path step failed.");return new hr(BigInt(t.path),null==t.sibling?null:R.fromJSON(t.sibling),null!=t.branch?cr.fromJSON(t.branch):null)}static fromCBOR(t){const e=N.readArray(t);return new hr(ar.decode(N.readByteString(e[0])),N.readOptional(e[1],R.fromCBOR),N.readOptional(e[2],cr.fromCBOR))}toCBOR(){return O.encodeArray([O.encodeByteString(ar.encode(this.path)),this.sibling?.toCBOR()??O.encodeNull(),this.branch?.toCBOR()??O.encodeNull()])}toJSON(){return{branch:this.branch?.toJSON()??null,path:this.path.toString(),sibling:this.sibling?.toJSON()??null}}toString(){return nr`
      Merkle Tree Path Step
        Path: ${this.path.toString(2)}
        Branch: ${this.branch?.toString()??"null"}
        Sibling: ${this.sibling?.toString()??"null"}`}}class ur{isPathValid;isPathIncluded;result;constructor(t,e){this.isPathValid=t,this.isPathIncluded=e,this.result=t&&e}}class lr{root;steps;constructor(t,e){this.root=t,this.steps=e}static fromJSON(t){if(!lr.isJSON(t))throw new Error("Parsing merkle tree path json failed.");return new lr(R.fromJSON(t.root),t.steps.map(t=>hr.fromJSON(t)))}static isJSON(t){return"object"==typeof t&&null!==t&&"root"in t&&"string"==typeof t.root&&"steps"in t&&Array.isArray(t.steps)}static fromCBOR(t){const e=N.readArray(t),r=N.readArray(e[1]);return new lr(R.fromCBOR(e[0]),r.map(t=>hr.fromCBOR(t)))}toCBOR(){return O.encodeArray([this.root.toCBOR(),O.encodeArray(this.steps.map(t=>t.toCBOR()))])}toJSON(){return{root:this.root.toJSON(),steps:this.steps.map(t=>t.toJSON())}}async verify(t){let e=1n,r=null;for(let t=0;t<this.steps.length;t++){const n=this.steps[t];let i;if(null===n.branch)i=new Uint8Array(1);else{const o=0===t?n.branch.value:r?.data;i=(await new vt(A.SHA256).update(ar.encode(n.path)).update(o??new Uint8Array(1)).digest()).data;const s=BigInt(n.path.toString(2).length-1);e=e<<s|n.path&(1n<<s)-1n}const o=n.sibling?.data??new Uint8Array(1),s=1n&n.path;r=await new vt(A.SHA256).update(s?o:i).update(s?i:o).digest()}return new ur(!!r&&this.root.equals(r),t===e)}toString(){return nr`
      Merkle Tree Path
        Root: ${this.root.toString()} 
        Steps: [
          ${this.steps.map(t=>t?.toString()??"null").join("\n")}
        ]`}}var dr,fr;!function(t){t.NOT_AUTHENTICATED="NOT_AUTHENTICATED",t.PATH_NOT_INCLUDED="PATH_NOT_INCLUDED",t.PATH_INVALID="PATH_INVALID",t.OK="OK"}(dr||(dr={}));class gr{merkleTreePath;authenticator;transactionHash;constructor(t,e,r){if(this.merkleTreePath=t,this.authenticator=e,this.transactionHash=r,!this.authenticator!=!this.transactionHash)throw new Error("Authenticator and transaction hash must be both set or both null.")}static isJSON(t){return"object"==typeof t&&null!==t&&"merkleTreePath"in t}static fromJSON(t){if(!gr.isJSON(t))throw new Error("Parsing inclusion proof json failed.");return new gr(lr.fromJSON(t.merkleTreePath),t.authenticator?ir.fromJSON(t.authenticator):null,t.transactionHash?R.fromJSON(t.transactionHash):null)}static fromCBOR(t){const e=N.readArray(t),r=N.readOptional(e[1],ir.fromCBOR),n=N.readOptional(e[2],R.fromCBOR);return new gr(lr.fromCBOR(e[0]),r,n)}toJSON(){return{authenticator:this.authenticator?.toJSON()??null,merkleTreePath:this.merkleTreePath.toJSON(),transactionHash:this.transactionHash?.toJSON()??null}}toCBOR(){return O.encodeArray([this.merkleTreePath.toCBOR(),this.authenticator?.toCBOR()??O.encodeNull(),this.transactionHash?.toCBOR()??O.encodeNull()])}async verify(t){if(this.authenticator&&this.transactionHash){if(!await this.authenticator.verify(this.transactionHash))return dr.NOT_AUTHENTICATED;if(!(await or.create(this.authenticator,this.transactionHash)).equals(this.merkleTreePath.steps.at(0)?.branch?.value))return dr.PATH_NOT_INCLUDED}const e=await this.merkleTreePath.verify(t);return e.isPathValid?e.isPathIncluded?dr.OK:dr.PATH_NOT_INCLUDED:dr.PATH_INVALID}toString(){return nr`
      Inclusion Proof
        ${this.merkleTreePath.toString()}
        ${this.authenticator?.toString()}
        Transaction Hash: ${this.transactionHash?.toString()??null}`}}class yr{requestId;transactionHash;authenticator;receipt;constructor(t,e,r,n){this.requestId=t,this.transactionHash=e,this.authenticator=r,this.receipt=n}static fromJSON(t){if(!yr.isJSON(t))throw new Error("Parsing submit state transition request failed.");return new yr(_t.fromJSON(t.requestId),R.fromJSON(t.transactionHash),ir.fromJSON(t.authenticator),t.receipt)}static isJSON(t){return"object"==typeof t&&null!==t&&"authenticator"in t&&"object"==typeof t.authenticator&&null!==t.authenticator&&"requestId"in t&&"string"==typeof t.requestId&&"transactionHash"in t&&"string"==typeof t.transactionHash}toJSON(){return{authenticator:this.authenticator.toJSON(),receipt:this.receipt,requestId:this.requestId.toJSON(),transactionHash:this.transactionHash.toJSON()}}}!function(t){t.SUCCESS="SUCCESS",t.AUTHENTICATOR_VERIFICATION_FAILED="AUTHENTICATOR_VERIFICATION_FAILED",t.REQUEST_ID_MISMATCH="REQUEST_ID_MISMATCH",t.REQUEST_ID_EXISTS="REQUEST_ID_EXISTS"}(fr||(fr={}));class pr{service;method;requestId;stateHash;transactionHash;hash;constructor(t,e,r,n,i,o){this.service=t,this.method=e,this.requestId=r,this.stateHash=n,this.transactionHash=i,this.hash=o}static async create(t,e,r,n,i){const o=O.encodeArray([O.encodeTextString(t),O.encodeTextString(e),r.toCBOR(),n.toCBOR(),i.toCBOR()]),s=await new vt(A.SHA256).update(o).digest();return new pr(t,e,r,n,i,s)}toCBOR(){return O.encodeArray([O.encodeTextString(this.service),O.encodeTextString(this.method),this.requestId.toCBOR(),this.stateHash.toCBOR(),this.transactionHash.toCBOR()])}toJSON(){return{method:this.method,requestId:this.requestId.toJSON(),service:this.service,stateHash:this.stateHash.toJSON(),transactionHash:this.transactionHash.toJSON()}}toString(){return nr`
      Request
        Service: ${this.service}
        Method: ${this.method}
        Request ID: ${this.requestId.toString()}
        State Hash: ${this.stateHash.toString()}
        Transaction Hash: ${this.transactionHash.toString()}
      `}}class mr{status;receipt;constructor(t,e){this.status=t,this.receipt=e}static async fromJSON(t){if(!mr.isJSON(t))throw new Error("Parsing submit state transition response failed.");let e;if(t.request&&t.algorithm&&t.publicKey&&t.signature){const r=await pr.create(t.request.service,t.request.method,_t.fromJSON(t.request.requestId),R.fromJSON(t.request.stateHash),R.fromJSON(t.request.transactionHash));e={algorithm:t.algorithm,publicKey:t.publicKey,request:r,signature:Ct.fromJSON(t.signature)}}return new mr(t.status,e)}static isJSON(t){return"object"==typeof t&&null!==t&&"status"in t&&"string"==typeof t.status}toJSON(){return{algorithm:this.receipt?.algorithm,publicKey:this.receipt?.publicKey,request:this.receipt?.request.toJSON(),signature:this.receipt?.signature.toJSON(),status:this.status}}async addSignedReceipt(t,e,r,n){const i=await pr.create("aggregator","submit_commitment",t,e,r),o=await n.sign(i.hash);this.receipt={algorithm:n.algorithm,publicKey:b.encode(n.publicKey),request:i,signature:o}}verifyReceipt(){return this.receipt?rr.verifyWithPublicKey(this.receipt.request.hash,this.receipt.signature.bytes,b.decode(this.receipt.publicKey)):Promise.resolve(!1)}}const wr={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let Sr;const br=new Uint8Array(16),Or=[];for(let t=0;t<256;++t)Or.push((t+256).toString(16).slice(1));const Ar=function(t,e,r){if(wr.randomUUID&&!e&&!t)return wr.randomUUID();const n=(t=t||{}).random??t.rng?.()??function(){if(!Sr){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");Sr=crypto.getRandomValues.bind(crypto)}return Sr(br)}();if(n.length<16)throw new Error("Random bytes length must be >= 16");if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){if((r=r||0)<0||r+16>e.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let t=0;t<16;++t)e[r+t]=n[t];return e}return function(t,e=0){return(Or[t[e+0]]+Or[t[e+1]]+Or[t[e+2]]+Or[t[e+3]]+"-"+Or[t[e+4]]+Or[t[e+5]]+"-"+Or[t[e+6]]+Or[t[e+7]]+"-"+Or[t[e+8]]+Or[t[e+9]]+"-"+Or[t[e+10]]+Or[t[e+11]]+Or[t[e+12]]+Or[t[e+13]]+Or[t[e+14]]+Or[t[e+15]]).toLowerCase()}(n)};class Br{code;message;name="JsonRpcError";constructor({code:t,message:e}){this.code=t,this.message=e}toString(){return`{ code: ${this.code}, message: ${this.message} }`}}class Er{status;message;name="JsonRpcNetworkError";constructor(t,e){this.status=t,this.message=e}}class Nr{url;constructor(t){this.url=t}async request(t,e){const r=await fetch(this.url,{body:JSON.stringify({id:Ar(),jsonrpc:"2.0",method:t,params:e}),headers:{"Content-Type":"application/json"},method:"POST"});if(!r.ok)throw new Er(r.status,await r.text());const n=await r.json();if(n.error)throw new Br(n.error);return n.result}}class Rr{transport;constructor(t){this.transport=new Nr(t)}async submitTransaction(t,e,r,n=!1){const i=new yr(t,e,r,n),o=await this.transport.request("submit_commitment",i.toJSON());return mr.fromJSON(o)}async getInclusionProof(t,e){const r={blockNum:e?.toString(),requestId:t.toJSON()};return gr.fromJSON(await this.transport.request("get_inclusion_proof",r))}getNoDeletionProof(t){const e={requestId:t.toJSON()};return this.transport.request("get_no_deletion_proof",e)}async getBlockHeight(){const t=await this.transport.request("get_block_height",{});if(t&&"object"==typeof t&&"blockNumber"in t&&("string"==typeof t.blockNumber||"number"==typeof t.blockNumber||"bigint"==typeof t.blockNumber))return BigInt(t.blockNumber);throw new Error("Invalid response format for block height")}}var Ir;!function(t){t.MASKED="MASKED",t.UNMASKED="UNMASKED",t.BURN="BURN"}(Ir||(Ir={}));const Tr=Ir.BURN;class vr{reference;hash;_nonce;reason;type=Tr;constructor(t,e,r,n){this.reference=t,this.hash=e,this._nonce=r,this.reason=n}get nonce(){return new Uint8Array(this._nonce)}static async create(t,e,r,n){const i=await vr.calculateReference(e,n),o=await vr.calculateHash(i,t,r);return new vr(i,o,r,n)}static fromJSON(t,e,r){if(!vr.isJSON(r))throw new Error("Invalid burn predicate json");return vr.create(t,e,b.decode(r.nonce),R.fromJSON(r.reason))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.BURN)throw new Error(`Invalid predicate type: expected ${Ir.BURN}, got ${i}`);return vr.create(t,e,N.readByteString(n[1]),R.fromCBOR(n[2]))}static calculateReference(t,e){return new vt(A.SHA256).update(O.encodeArray([O.encodeTextString(Tr),t.toCBOR(),e.toCBOR()])).digest()}static isJSON(t){return"object"==typeof t&&null!==t&&"type"in t&&t.type===Ir.BURN&&"nonce"in t&&"string"==typeof t.nonce&&"reason"in t&&"string"==typeof t.reason}static calculateHash(t,e,r){return new vt(A.SHA256).update(O.encodeArray([t.toCBOR(),e.toCBOR(),O.encodeByteString(r)])).digest()}toJSON(){return{nonce:b.encode(this._nonce),reason:this.reason.toJSON(),type:this.type}}toCBOR(){return O.encodeArray([O.encodeTextString(this.type),O.encodeByteString(this._nonce),this.reason.toCBOR()])}verify(){return Promise.resolve(!1)}toString(){return nr`
          Predicate[${this.type}]:
            Hash: ${this.hash.toString()}`}isOwner(){return Promise.resolve(!1)}}class xr{type;_publicKey;algorithm;hashAlgorithm;_nonce;reference;hash;constructor(t,e,r,n,i,o,s){this.type=t,this._publicKey=e,this.algorithm=r,this.hashAlgorithm=n,this._nonce=i,this.reference=o,this.hash=s,this._publicKey=new Uint8Array(e),this._nonce=new Uint8Array(i)}get publicKey(){return this._publicKey}get nonce(){return this._nonce}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"hashAlgorithm"in t&&!!A[t.hashAlgorithm]&&"nonce"in t&&"string"==typeof t.nonce}toJSON(){return{algorithm:this.algorithm,hashAlgorithm:this.hashAlgorithm,nonce:b.encode(this.nonce),publicKey:b.encode(this.publicKey),type:this.type}}toCBOR(){return O.encodeArray([O.encodeTextString(this.type),O.encodeByteString(this.publicKey),O.encodeTextString(this.algorithm),O.encodeTextString(A[this.hashAlgorithm]),O.encodeByteString(this.nonce)])}async verify(t){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;if(b.encode(t.inclusionProof.authenticator.publicKey)!==b.encode(this.publicKey)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const e=await _t.create(this.publicKey,t.data.sourceState.hash);return await t.inclusionProof.verify(e.toBigInt())===dr.OK}toString(){return nr`
          Predicate[${this.type}]:
            PublicKey: ${b.encode(this.publicKey)}
            Algorithm: ${this.algorithm}
            Hash Algorithm: ${A[this.hashAlgorithm]}
            Nonce: ${b.encode(this.nonce)}
            Hash: ${this.hash.toString()}`}isOwner(t){return Promise.resolve(b.encode(t)===b.encode(this.publicKey))}}const _r=Ir.MASKED;class Cr extends xr{constructor(t,e,r,n,i,o){super(_r,t,e,r,n,i,o)}static create(t,e,r,n,i){return Cr.createFromPublicKey(t,e,r.algorithm,r.publicKey,n,i)}static async createFromPublicKey(t,e,r,n,i,o){const s=await Cr.calculateReference(e,r,n,i,o),a=await Cr.calculateHash(s,t);return new Cr(n,r,i,o,s,a)}static fromJSON(t,e,r){if(!xr.isJSON(r)||r.type!==_r)throw new Error("Invalid masked predicate json.");return Cr.createFromPublicKey(t,e,r.algorithm,b.decode(r.publicKey),r.hashAlgorithm,b.decode(r.nonce))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.MASKED)throw new Error(`Invalid predicate type: expected ${Ir.MASKED}, got ${i}`);const o=N.readTextString(n[3]);if(!A[o])throw new Error(`Invalid hash algorithm: ${o}`);return Cr.createFromPublicKey(t,e,N.readTextString(n[2]),N.readByteString(n[1]),o,N.readByteString(n[4]))}static calculateReference(t,e,r,n,i){return new vt(A.SHA256).update(O.encodeArray([O.encodeTextString(_r),t.toCBOR(),O.encodeTextString(e),O.encodeTextString(A[n]),O.encodeByteString(r),O.encodeByteString(i)])).digest()}static calculateHash(t,e){return new vt(A.SHA256).update(O.encodeArray([t.toCBOR(),e.toCBOR()])).digest()}}const Pr=Ir.UNMASKED;class Hr extends xr{constructor(t,e,r,n,i,o){super(Pr,t,e,r,n,i,o)}static async create(t,e,r,n,i){const o=await new vt(A.SHA256).update(i).digest(),s=await r.sign(o);return Hr.createFromPublicKey(t,e,r.algorithm,r.publicKey,n,s.bytes)}static async createFromPublicKey(t,e,r,n,i,o){const s=await Hr.calculateReference(e,r,n,i),a=await Hr.calculateHash(s,t,o);return new Hr(n,r,i,o,s,a)}static fromJSON(t,e,r){if(!xr.isJSON(r)||r.type!==Pr)throw new Error("Invalid unmasked predicate json.");return Hr.createFromPublicKey(t,e,r.algorithm,b.decode(r.publicKey),r.hashAlgorithm,b.decode(r.nonce))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.UNMASKED)throw new Error(`Invalid predicate type: expected ${Ir.UNMASKED}, got ${i}`);const o=N.readTextString(n[3]);if(!A[o])throw new Error(`Invalid hash algorithm: ${o}`);return Hr.createFromPublicKey(t,e,N.readTextString(n[2]),N.readByteString(n[1]),o,N.readByteString(n[4]))}static calculateReference(t,e,r,n){return new vt(A.SHA256).update(O.encodeArray([O.encodeTextString(Pr),t.toCBOR(),O.encodeTextString(e),O.encodeTextString(A[n]),O.encodeByteString(r)])).digest()}static calculateHash(t,e,r){return new vt(A.SHA256).update(O.encodeArray([t.toCBOR(),e.toCBOR(),O.encodeByteString(r)])).digest()}}class Ur{create(t,e,r){switch(r.type){case Ir.BURN:return vr.fromJSON(t,e,r);case Ir.MASKED:return Cr.fromJSON(t,e,r);case Ir.UNMASKED:return Hr.fromJSON(t,e,r);default:throw new Error(`Unknown predicate type: ${r.type}`)}}}class Jr{static decode(){return Promise.resolve(new Jr)}toJSON(){throw new Error("toJSON method is not implemented.")}toCBOR(){throw new Error("toCBOR method is not implemented.")}}const kr="2.0";class Dr{state;genesis;_transactions;_nametagTokens;version;constructor(t,e,r=[],n=[],i=kr){this.state=t,this.genesis=e,this._transactions=r,this._nametagTokens=n,this.version=i,this._nametagTokens=n.slice(),this._transactions=r.slice()}get id(){return this.genesis.data.tokenId}get type(){return this.genesis.data.tokenType}get data(){return this.genesis.data.tokenData}get coins(){return this.genesis.data.coinData}get nametagTokens(){return this._nametagTokens.slice()}get transactions(){return this._transactions.slice()}toJSON(){return{genesis:this.genesis.toJSON(),nametagTokens:[],state:this.state.toJSON(),transactions:this.transactions.map(t=>t.toJSON()),version:this.version}}toCBOR(){return O.encodeArray([O.encodeTextString(this.version),this.genesis.toCBOR(),O.encodeArray(this.transactions.map(t=>t.toCBOR())),this.state.toCBOR(),O.encodeArray(this.nametagTokens.map(t=>t.toCBOR()))])}toString(){return nr`
        Token[${this.version}]:
          Id: ${this.id.toString()}
          Type: ${this.type.toString()}
          Data: 
            ${this.data.toString()}
          Coins:
            ${this.coins?.toString()??null}
          State:
            ${this.state.toString()}
          Transactions: [
            ${this.transactions.map(t=>t.toString()).join("\n")}
          ]
          Nametag Tokens: [ 
            ${this.nametagTokens.map(t=>t.toString()).join("\n")}
          ]
      `}}class Kr{requestId;transactionData;authenticator;_brand="Commitment";constructor(t,e,r){this.requestId=t,this.transactionData=e,this.authenticator=r}}class qr{data;inclusionProof;constructor(t,e){this.data=t,this.inclusionProof=e}toJSON(){return{data:this.data.toJSON(),inclusionProof:this.inclusionProof.toJSON()}}toCBOR(){return O.encodeArray([this.data.toCBOR(),this.inclusionProof.toCBOR()])}async containsData(t){return this.data.dataHash?!!t&&(await new vt(this.data.dataHash.algorithm).update(t).digest()).equals(this.data.dataHash):!t}toString(){return nr`
        Transaction:
          ${this.data.toString()}
          ${this.inclusionProof.toString()}`}}const $r=b.decode("495f414d5f554e4956455253414c5f4d494e5445525f464f525f");class Mr{client;constructor(t){this.client=t}async submitMintTransaction(t){return this.sendTransaction(t,await rr.createFromSecret($r,t.tokenId.bytes))}async submitTransaction(t,e){if(!await t.sourceState.unlockPredicate.isOwner(e.publicKey))throw new Error("Failed to unlock token");return this.sendTransaction(t,e)}async createTransaction({requestId:t,transactionData:e},r){if(await r.verify(t.toBigInt())!=dr.OK)throw new Error("Inclusion proof verification failed.");if(!r.authenticator||!A[r.authenticator.stateHash.algorithm])throw new Error("Invalid inclusion proof hash algorithm.");if(!r.transactionHash?.equals(e.hash))throw new Error("Payload hash mismatch");return new qr(e,r)}async finishTransaction(t,e,r,n=[]){if(!await r.data.sourceState.unlockPredicate.verify(r))throw new Error("Predicate verification failed");if((await xt.create(e.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");const i=[...t.transactions,r];if(!await r.containsData(e.data))throw new Error("State data is not part of transaction.");return new Dr(e,t.genesis,i,n)}async getTokenStatus(t,e){const r=await _t.create(e,t.state.hash);return(await this.client.getInclusionProof(r)).verify(r.toBigInt())}getInclusionProof(t){return this.client.getInclusionProof(t.requestId)}async sendTransaction(t,e){const r=await _t.create(e.publicKey,t.sourceState.hash),n=await ir.create(e,t.hash,t.sourceState.hash),i=await this.client.submitTransaction(r,t.hash,n);if(i.status!==fr.SUCCESS)throw new Error(`Could not submit transaction: ${i.status}`);return new Kr(r,t,n)}}var Lr;!function(t){t.TOKEN_SPLIT="TOKEN_SPLIT"}(Lr||(Lr={}));class Fr{token;_proofs;constructor(t,e){this.token=t,this._proofs=e,this._proofs=new Map(e)}get proofs(){return new Map(this._proofs)}toCBOR(){return O.encodeArray([this.token.toCBOR(),O.encodeArray(Array.from(this._proofs.entries()).map(([t,e])=>O.encodeArray([O.encodeByteString(ar.encode(t)),e.toCBOR()])))])}toJSON(){return{proofs:Array.from(this._proofs).map(([t,e])=>[t.toString(),e.toJSON()]),token:this.token.toJSON(),type:Lr.TOKEN_SPLIT}}}class jr{deserializer;constructor(t){this.deserializer=t}async create(t){const e=await this.deserializer.deserialize(t);if(!await this.verifyMintTransaction(e.genesis))throw new Error("Mint transaction verification failed.");let r=e.genesis;for(const t of e.transactions){if((await xt.create(t.data.sourceState.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");if(!await r.containsData(t.data.sourceState.data))throw new Error("State data is not part of transaction.");if(!await t.data.sourceState.unlockPredicate.verify(t))throw new Error("Predicate verification failed");r=t}if(!await r.containsData(e.state.data))throw new Error("State data is not part of transaction.");if((await xt.create(e.state.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");return e}async verifyMintTransaction(t){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;const e=await rr.createFromSecret($r,t.data.tokenId.bytes);if(b.encode(t.inclusionProof.authenticator.publicKey)!==b.encode(e.publicKey)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const r=t.data.reason;if(r instanceof Fr){if(null==t.data.coinData)return!1;if(r.token.state.unlockPredicate.type!=Ir.BURN)return!1;if(t.data.coinData.size!==r.proofs.size)return!1;for(const[e,n]of r.proofs){if(!(await n.aggregationPath.verify(e)).result)return!1;if(!(await n.coinTreePath.verify(t.data.tokenId.toBigInt())).result)return!1;const i=n.aggregationPath.steps.at(0)?.branch?.value;if(!i||!n.coinTreePath.root.equals(R.fromImprint(i)))return!1;const o=n.coinTreePath.steps.at(0)?.branch?.sum;if(t.data.coinData?.getByKey(e)!==o)return!1;const s=r.token.state.unlockPredicate;if(!n.aggregationPath.root.equals(s.reason))return!1}}const n=await _t.create(e.publicKey,t.data.sourceState.hash);return await t.inclusionProof.verify(n.toBigInt())===dr.OK}}class zr{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static create(t){return new zr(t)}toJSON(){return b.encode(this._bytes)}toCBOR(){return O.encodeByteString(this._bytes)}toString(){return`TokenId[${b.encode(this._bytes)}]`}toBigInt(){return BigInt(`0x01${b.encode(this.toCBOR())}`)}}class Gr{unlockPredicate;_data;hash;constructor(t,e,r){this.unlockPredicate=t,this._data=e,this.hash=r,this._data=e?new Uint8Array(e):null}get data(){return this._data?new Uint8Array(this._data):null}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e){return new Gr(t,e,await new vt(A.SHA256).update(O.encodeArray([t.hash.toCBOR(),O.encodeOptional(e,O.encodeByteString)])).digest())}toJSON(){return{data:this._data?b.encode(this._data):null,unlockPredicate:this.unlockPredicate.toJSON()}}toCBOR(){return O.encodeArray([this.unlockPredicate.toCBOR(),O.encodeOptional(this._data,O.encodeByteString)])}toString(){return nr`
        TokenState:
          ${this.unlockPredicate.toString()}
          Data: ${this._data?b.encode(this._data):null}
          Hash: ${this.hash.toString()}`}}class Vr{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static create(t){return new Vr(t)}toJSON(){return b.encode(this._bytes)}toCBOR(){return O.encodeByteString(this._bytes)}toString(){return`TokenType[${b.encode(this._bytes)}]`}}class Yr{data;constructor(t){this.data=t,this.data=new Uint8Array(t)}static fromJSON(t){return new Yr(b.decode(t))}static fromCBOR(t){return new Yr(N.readByteString(t))}static fromBigInt(t){return Yr.fromCBOR(b.decode(t.toString(16).slice(1)))}toJSON(){return b.encode(this.data)}toCBOR(){return O.encodeByteString(this.data)}toBigInt(){return BigInt(`0x01${b.encode(this.toCBOR())}`)}}class Zr{_coins;constructor(t){this._coins=new Map(t)}get size(){return this._coins.size}get coins(){return new Map(Array.from(this._coins.entries()).map(([t,e])=>[Yr.fromBigInt(t),e]))}static create(t){return new Zr(t.map(([t,e])=>[t.toBigInt(),e]))}static fromCBOR(t){const e=[],r=N.readArray(t);for(const t of r){const[r,n]=N.readArray(t);e.push([ar.decode(N.readByteString(r)),ar.decode(N.readByteString(n))])}return new Zr(e)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Invalid coin data JSON format");const e=[],r=t=>{if("bigint"==typeof t)return t;if("string"==typeof t||"number"==typeof t)return BigInt(t);if(null===t)throw new Error("Cannot convert null to BigInt. This indicates a JSON serialization issue with BigInt values.");if("object"==typeof t)throw new Error(`Cannot convert object to BigInt. This indicates a JSON serialization issue with BigInt values. Received: ${JSON.stringify(t)}`);throw new Error(`Unsupported type for BigInt conversion: ${typeof t}. Expected string, number, or bigint.`)};for(const[n,i]of t)e.push([r(n),r(i)]);return new Zr(e)}get(t){return this._coins.get(t.toBigInt())}getByKey(t){return this._coins.get(t)}toCBOR(){return O.encodeArray(Array.from(this._coins.entries()).map(([t,e])=>O.encodeArray([O.encodeByteString(ar.encode(t)),O.encodeByteString(ar.encode(e))])))}toJSON(){return Array.from(this._coins.entries()).map(([t,e])=>[t.toString(),e.toString()])}toString(){return nr`
      FungibleTokenData
        ${Array.from(this._coins.entries()).map(([t,e])=>`${t}: ${e}`).join("\n")}`}}const Wr=b.decode("9e82002c144d7c5796c50f6db50a0c7bbd7f717ae3af6c6c71a3e9eba3022730");class Xr{hash;tokenId;tokenType;_tokenData;coinData;sourceState;recipient;_salt;dataHash;reason;constructor(t,e,r,n,i,o,s,a,c,h){this.hash=t,this.tokenId=e,this.tokenType=r,this._tokenData=n,this.coinData=i,this.sourceState=o,this.recipient=s,this._salt=a,this.dataHash=c,this.reason=h,this._tokenData=new Uint8Array(n),this._salt=new Uint8Array(a)}get tokenData(){return new Uint8Array(this._tokenData)}get salt(){return new Uint8Array(this._salt)}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e,r,n,i,o,s,a){const c=await _t.createFromImprint(t.bytes,Wr),h=await new vt(A.SHA256).update(r).digest();return new Xr(await new vt(A.SHA256).update(O.encodeArray([t.toCBOR(),e.toCBOR(),h.toCBOR(),s?.toCBOR()??O.encodeNull(),n?.toCBOR()??O.encodeNull(),O.encodeTextString(i),O.encodeByteString(o),a?.toCBOR()??O.encodeNull()])).digest(),t,e,r,n,c,i,o,s,a)}toJSON(){return{coins:this.coinData?.toJSON()??null,dataHash:this.dataHash?.toJSON()??null,reason:this.reason?.toJSON()??null,recipient:this.recipient,salt:b.encode(this._salt),tokenData:b.encode(this._tokenData),tokenId:this.tokenId.toJSON(),tokenType:this.tokenType.toJSON()}}toCBOR(){return O.encodeArray([this.tokenId.toCBOR(),this.tokenType.toCBOR(),O.encodeByteString(this._tokenData),this.coinData?.toCBOR()??O.encodeNull(),O.encodeTextString(this.recipient),O.encodeByteString(this._salt),this.dataHash?.toCBOR()??O.encodeNull(),this.reason?.toCBOR()??O.encodeNull()])}toString(){return nr`
      MintTransactionData:
        Token ID: ${this.tokenId.toString()}
        Token Type: ${this.tokenType.toString()}
        Token Data: ${b.encode(this._tokenData)}
        Coins: ${this.coinData?.toString()??null}
        Recipient: ${this.recipient}
        Salt: ${b.encode(this.salt)}
        Data: ${this.dataHash?.toString()??null}
        Reason: ${this.reason?.toString()??null}
        Hash: ${this.hash.toString()}`}}class Qr{hash;sourceState;recipient;salt;dataHash;_message;nameTags;constructor(t,e,r,n,i,o,s=[]){this.hash=t,this.sourceState=e,this.recipient=r,this.salt=n,this.dataHash=i,this._message=o,this.nameTags=s,this._message=o?new Uint8Array(o):null,this.nameTags=Array.from(s)}get message(){return this._message?new Uint8Array(this._message):null}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e,r,n,i,o=[]){return new Qr(await new vt(A.SHA256).update(O.encodeArray([t.hash.toCBOR(),n?.toCBOR()??O.encodeNull(),O.encodeTextString(e),O.encodeByteString(r),O.encodeOptional(i,O.encodeByteString)])).digest(),t,e,r,n,i,o)}toJSON(){return{dataHash:this.dataHash?.toJSON()??null,message:this._message?b.encode(this._message):null,nameTags:this.nameTags.map(t=>t.toJSON()),recipient:this.recipient,salt:b.encode(this.salt),sourceState:this.sourceState.toJSON()}}toCBOR(){return O.encodeArray([this.sourceState.toCBOR(),O.encodeTextString(this.recipient),O.encodeByteString(this.salt),this.dataHash?.toCBOR()??O.encodeNull(),this._message?O.encodeByteString(this._message):O.encodeNull(),O.encodeArray(this.nameTags.map(t=>t.toCBOR()))])}toString(){return nr`
      TransactionData:
        ${this.sourceState.toString()}
        Recipient: ${this.recipient.toString()}
        Salt: ${b.encode(this.salt)}
        Data: ${this.dataHash?.toString()??null}
        Message: ${this._message?b.encode(this._message):null}
        NameTags: [
          ${this.nameTags.map(t=>t.toString()).join("\n")}
        ]
        Hash: ${this.hash.toString()}`}}class tn{requestId;transactionData;authenticator;_brand="OfflineCommitment";constructor(t,e,r){this.requestId=t,this.transactionData=e,this.authenticator=r}}class en extends Error{constructor(t){super(t),this.name="SleepError"}}function rn(t,e){return new Promise((r,n)=>{const i=setTimeout(r,t);e.addEventListener("abort",()=>{clearTimeout(i),n(e.reason)},{once:!0})})}class nn extends Mr{async createOfflineCommitment(t,e){if(!await t.sourceState.unlockPredicate.isOwner(e.publicKey))throw new Error("Failed to unlock token");const r=await _t.create(e.publicKey,t.sourceState.hash),n=await ir.create(e,t.hash,t.sourceState.hash);return new tn(r,t,n)}async submitOfflineTransaction({requestId:t,transactionData:e,authenticator:r}){const n=await this.client.submitTransaction(t,e.hash,r,!1);if(n.status!==fr.SUCCESS)throw new Error(`Could not submit transaction: ${n.status}`);const i=new Kr(t,e,r);return await this.createTransaction(i,await async function(t,e,r=AbortSignal.timeout(1e4),n=1e3){for(;;){try{const r=await t.getInclusionProof(e);if(await r.verify(e.requestId.toBigInt())===dr.OK)return r}catch(t){if(!(t instanceof Er&&404===t.status))throw t}try{await rn(n,r)}catch(t){throw new en(String(t||"Sleep was aborted"))}}}(this,i))}}class on{path;_value;sum;hash;constructor(t,e,r,n){this.path=t,this._value=e,this.sum=r,this.hash=n}get value(){return new Uint8Array(this._value)}finalize(){return Promise.resolve(this)}toString(){return nr`
      Leaf[${this.path.toString(2)}]
        Hash: ${this.hash.toString()}
        Value: ${b.encode(this._value)}
        Sum: ${this.sum}`}}class sn{sum;hash;constructor(t,e){this.sum=t,this.hash=e}static create(t){return new sn(t.sum,t.hash)}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t)||2!==t.length)throw new Error("Parsing merkle tree path step branch failed.");return new sn(BigInt(t[0]),R.fromJSON(t[1]))}static fromCBOR(t){const e=N.readArray(t);return new sn(ar.decode(N.readByteString(e[0])),R.fromCBOR(e[1]))}toCBOR(){return O.encodeArray([O.encodeByteString(ar.encode(this.sum)),this.hash.toCBOR()])}toJSON(){return[this.sum.toString(),this.hash.toJSON()]}toString(){return`MerkleSumTreePathStepSibling[${this.sum},${this.hash.toString()}]`}}class an{sum;_value;constructor(t,e){this.sum=t,this._value=e,this._value=e?new Uint8Array(e):null}get value(){return this._value?new Uint8Array(this._value):null}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Parsing merkle tree path step branch failed.");const e=t.at(0),r=t.at(1);return new an(BigInt(e??0n),r?b.decode(r):null)}static fromCBOR(t){const e=N.readArray(t);return new an(ar.decode(N.readByteString(e[0])),N.readOptional(e[1],N.readByteString))}toCBOR(){return O.encodeArray([O.encodeOptional(this._value,O.encodeByteString)])}toJSON(){return[this.sum.toString(),this._value?b.encode(this._value):null]}toString(){return`MerkleSumTreePathStepBranch[${this._value?b.encode(this._value):"null"}]`}}class cn{path;sibling;branch;constructor(t,e,r){this.path=t,this.sibling=e,this.branch=r}static createWithoutBranch(t,e){return new cn(t,e?sn.create(e):null,null)}static create(t,e,r){return new cn(t,r?sn.create(r):null,null==e?new an(0n,null):new an(e.sum,e instanceof on?e.value:e.childrenHash.data))}static isJSON(t){return"object"==typeof t&&null!==t&&"path"in t&&"string"==typeof t.path&&"sibling"in t&&"branch"in t}static fromJSON(t){if(!cn.isJSON(t))throw new Error("Parsing merkle tree path step failed.");return new cn(BigInt(t.path),null!=t.sibling?sn.fromJSON(t.sibling):null,null!=t.branch?an.fromJSON(t.branch):null)}static fromCBOR(t){const e=N.readArray(t);return new cn(ar.decode(N.readByteString(e[0])),N.readOptional(e[1],sn.fromCBOR),N.readOptional(e[2],an.fromCBOR))}toCBOR(){return O.encodeArray([O.encodeByteString(ar.encode(this.path)),this.sibling?.toCBOR()??O.encodeNull(),this.branch?.toCBOR()??O.encodeNull()])}toJSON(){return{branch:this.branch?.toJSON()??null,path:this.path.toString(),sibling:this.sibling?.toJSON()??null}}toString(){return nr`
      Merkle Tree Path Step
        Path: ${this.path.toString(2)}
        Branch: ${this.branch?.toString()??"null"}
        Sibling: ${this.sibling?.toString()??"null"}`}}class hn{root;sum;steps;constructor(t,e,r){this.root=t,this.sum=e,this.steps=r}static fromJSON(t){if(!hn.isJSON(t))throw new Error("Parsing merkle tree path json failed.");return new hn(R.fromJSON(t.root),BigInt(t.sum),t.steps.map(t=>cn.fromJSON(t)))}static isJSON(t){return"object"==typeof t&&null!==t&&"root"in t&&"string"==typeof t.root&&"steps"in t&&Array.isArray(t.steps)}static fromCBOR(t){const e=N.readArray(t);return new hn(R.fromCBOR(e[0]),ar.decode(N.readByteString(e[1])),N.readArray(e[2]).map(t=>cn.fromCBOR(t)))}toCBOR(){return O.encodeArray([this.root.toCBOR(),O.encodeArray(this.steps.map(t=>t.toCBOR()))])}toJSON(){return{root:this.root.toJSON(),steps:this.steps.map(t=>t.toJSON()),sum:this.sum.toString()}}async verify(t){let e=1n,r=null,n=this.steps.at(0)?.branch?.sum??0n;for(let t=0;t<this.steps.length;t++){const i=this.steps[t];let o=null;if(null!==i.branch){const s=0===t?i.branch.value:r?r.imprint:null;o=await new vt(A.SHA256).update(O.encodeArray([O.encodeByteString(ar.encode(i.path)),s?O.encodeByteString(s):O.encodeNull(),O.encodeByteString(ar.encode(n))])).digest();const a=BigInt(i.path.toString(2).length-1);e=e<<a|i.path&(1n<<a)-1n}const s=1n&i.path,a=s?o?[o,n]:null:i.sibling?[i.sibling.hash,i.sibling.sum]:null,c=s?i.sibling?[i.sibling.hash,i.sibling.sum]:null:o?[o,n]:null;r=await new vt(A.SHA256).update(O.encodeArray([c?O.encodeArray([O.encodeByteString(c[0].imprint),O.encodeByteString(ar.encode(c[1]))]):O.encodeNull(),a?O.encodeArray([a[0]?O.encodeByteString(a[0].imprint):O.encodeNull(),O.encodeByteString(ar.encode(a[1]))]):O.encodeNull()])).digest(),n+=i.sibling?.sum??0n}return new ur(!!r&&this.root.equals(r)&&n===this.sum,t===e)}toString(){return nr`
      Merkle Tree Path
        Root: ${this.root.toString()} 
        Steps: [
          ${this.steps.map(t=>t?.toString()??"null").join("\n")}
        ]`}}class un{aggregationPath;coinTreePath;constructor(t,e){this.aggregationPath=t,this.coinTreePath=e}toJSON(){return{aggregationPath:this.aggregationPath.toJSON(),coinTreePath:this.coinTreePath.toJSON()}}toCBOR(){return O.encodeArray([this.aggregationPath.toCBOR(),this.coinTreePath.toCBOR()])}}class ln{tokenDeserializer;constructor(t){this.tokenDeserializer=t}async deserialize({data:t,inclusionProof:e}){return new qr(await Xr.create(zr.create(b.decode(t.tokenId)),Vr.create(b.decode(t.tokenType)),b.decode(t.tokenData),t.coins?Zr.fromJSON(t.coins):null,t.recipient,b.decode(t.salt),t.dataHash?R.fromJSON(t.dataHash):null,t.reason?await this.createMintReason(t.reason):null),gr.fromJSON(e))}createMintReason(t){if(t.type===Lr.TOKEN_SPLIT)return this.createSplitMintReason(t);throw new Error(`Unsupported mint reason type: ${t.type}`)}async createSplitMintReason(t){const e=new Map;for(const[r,n]of t.proofs)e.set(BigInt(r),new un(lr.fromJSON(n.aggregationPath),hn.fromJSON(n.coinTreePath)));return new Fr(await this.tokenDeserializer.deserialize(t.token),e)}}class dn{predicateFactory;constructor(t){this.predicateFactory=t}async deserialize(t,e,{data:r,inclusionProof:n}){return new qr(await Qr.create(await Gr.create(await this.predicateFactory.create(t,e,r.sourceState.unlockPredicate),r.sourceState.data?b.decode(r.sourceState.data):null),r.recipient,b.decode(r.salt),r.dataHash?R.fromJSON(r.dataHash):null,r.message?b.decode(r.message):null,[]),gr.fromJSON(n))}}class fn{predicateFactory;mintTransactionDeserializer;transactionDeserializer;constructor(t){this.predicateFactory=t,this.mintTransactionDeserializer=new ln(this),this.transactionDeserializer=new dn(t)}async deserialize(t){const e=t.version;if(e!==kr)throw new Error(`Cannot parse token. Version mismatch: ${e} !== ${kr}`);const r=await this.mintTransactionDeserializer.deserialize(t.genesis),n=[];for(const e of t.transactions)n.push(await this.transactionDeserializer.deserialize(r.data.tokenId,r.data.tokenType,e));return new Dr(await Gr.create(await this.predicateFactory.create(r.data.tokenId,r.data.tokenType,t.state.unlockPredicate),t.state.data?b.decode(t.state.data):null),r,n,[],e)}}class gn{static stringify(t,e){return JSON.stringify(t,(t,e)=>"bigint"==typeof e?e.toString():e,e)}static parse(t){return JSON.parse(t)}static safeStringify(t,e){if(t&&"object"==typeof t&&"toJSON"in t&&"function"==typeof t.toJSON){const r=t.toJSON();return gn.stringify(r,e)}return gn.stringify(t,e)}}class yn{commitment;token;constructor(t,e){this.commitment=t,this.token=e}static async fromJSON(t){if(!yn.isJSON(t))throw new Error("Invalid offline transaction JSON format");const e=new Ur,r=new jr(new fn(e)),n=await r.create(t.token),i=_t.fromJSON(t.commitment.requestId),o=ir.fromJSON(t.commitment.authenticator),s=t.commitment.transactionData,a=await Qr.create(await Gr.create(await e.create(n.id,n.type,s.sourceState.unlockPredicate),s.sourceState.data?b.decode(s.sourceState.data):null),s.recipient,b.decode(s.salt),s.dataHash?R.fromJSON(s.dataHash):null,s.message?b.decode(s.message):null,[]),c=new tn(i,a,o);return new yn(c,n)}static fromJSONString(t){const e=gn.parse(t);return yn.fromJSON(e)}static isJSON(t){return"object"==typeof t&&null!==t&&"commitment"in t&&"token"in t&&"object"==typeof t.commitment&&"object"==typeof t.token}toCBOR(){return O.encodeArray([O.encodeArray([this.commitment.requestId.toCBOR(),this.commitment.transactionData.toCBOR(),this.commitment.authenticator.toCBOR()]),this.token.toCBOR()])}toJSON(){return{commitment:{authenticator:this.commitment.authenticator.toJSON(),requestId:this.commitment.requestId.toJSON(),transactionData:this.commitment.transactionData.toJSON()},token:this.token.toJSON()}}toJSONString(t){return gn.safeStringify(this,t)}}return n})());